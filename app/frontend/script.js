document.addEventListener('DOMContentLoaded', () => {
    const chatWindow = document.getElementById('chat-window');
    const userInput = document.getElementById('user-input');
    const sendButton = document.getElementById('send-button');
    const previewButton = document.getElementById('preview-button');
    const repoInput = document.getElementById('repo-name');
    const branchInput = document.getElementById('branch-name');
    const filePathInput = document.getElementById('file-path');
    const fileContentInput = document.getElementById('file-content');

    // For local development, the backend runs on http://localhost:8000
    // For production, this URL will need to be the deployed backend URL.
    // Ensure this URL matches your backend deployment.
    const backendUrl = '/gemini/chat'; // Using relative path for proxy, or full URL: 'http://localhost:8000/gemini/chat';
    // const backendUrl = 'https://ai-delivery-framework-gemini-production.up.railway.app/gemini/chat';


    // chatHistory will store ModelContext Protocol (MCP) compliant ChatContextPart objects.
    // Example: { type: "chat", role: "user", parts: [{ type: "text", text: "Hello" }] }
    let mcpChatHistoryParts = [];

    function appendMessage(text, sender) {
        const messageDiv = document.createElement('div');
        messageDiv.classList.add('message');
        messageDiv.classList.add(sender === 'user' ? 'user-message' : 'model-message');
        messageDiv.innerHTML = text.replace(/\n/g, '<br>'); // Basic Markdown-like rendering for newlines
        chatWindow.appendChild(messageDiv);
        chatWindow.scrollTop = chatWindow.scrollHeight; // Auto-scroll to bottom
    }

    function escapeHtml(str) {
        return str.replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]));
    }

    async function sendMessage() {
        const messageText = userInput.value.trim();
        if (!messageText) return;

        appendMessage(messageText, 'user');

        // Create a User ChatContextPart for the current message
        const userMessagePart = {
            type: "chat", // MCP type for chat messages
            role: "user",
            parts: [{ type: "text", text: messageText }]
        };
        mcpChatHistoryParts.push(userMessagePart);

        userInput.value = ''; // Clear input field

        // Show a thinking indicator
       appendMessage("<i>Thinking...</i>", 'model');
       const thinkingMessageElement = chatWindow.lastChild;
        sendButton.disabled = true;

        try {
            // Construct the ModelContext object for the request
            const modelContextRequest = {
                // context_id: "unique-context-id-if-needed", // Optional: can be generated by backend or frontend
                parts: mcpChatHistoryParts // Send the whole history including the latest user message
            };

            console.log("Sending ModelContext to backend:", JSON.stringify(modelContextRequest, null, 2));

            const response = await fetch(backendUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(modelContextRequest),
            });

           if (thinkingMessageElement && thinkingMessageElement.parentNode === chatWindow) {
               chatWindow.removeChild(thinkingMessageElement); // Remove thinking message
           }
            sendButton.disabled = false;

            if (!response.ok) {
                let errorDetail = "Unknown error occurred";
                try {
                    const errorData = await response.json();
                    console.error('Error from backend:', response.status, errorData);
                    // Try to parse error from ModelContext if backend sends it that way
                    if (errorData.parts && errorData.parts.length > 0 &&
                        errorData.parts[0].parts && errorData.parts[0].parts.length > 0 &&
                        errorData.parts[0].parts[0].text) {
                        errorDetail = errorData.parts[0].parts[0].text;
                    } else if (errorData.detail) {
                        errorDetail = errorData.detail;
                    } else {
                        errorDetail = `Server error: ${response.statusText}`;
                    }
                } catch (e) {
                    errorDetail = `Server error: ${response.statusText} (Could not parse error response)`;
                }
                appendMessage(`Error: ${errorDetail}`, 'model');
                // Do not add this error to mcpChatHistoryParts as it's a response status, not a model message
                return;
            }

            const responseData = await response.json(); // This should be a ModelContext object
            console.log("Received ModelContext from backend:", JSON.stringify(responseData, null, 2));

            // Extract the model's response from the ModelContext
            // Assuming the backend returns a ModelContext with the model's latest ChatContextPart
            if (responseData.parts && responseData.parts.length > 0) {
                const lastPart = responseData.parts[responseData.parts.length - 1]; // Get the last part (should be model's response)

                if (lastPart.type === "chat" && lastPart.role === "model" && lastPart.parts && lastPart.parts.length > 0) {
                    const textSubPart = lastPart.parts.find(p => p.type === "text");
                    if (textSubPart && textSubPart.text) {
                        const modelResponseText = textSubPart.text;
                        appendMessage(modelResponseText, 'model');
                        // Add the model's valid ChatContextPart to history
                        mcpChatHistoryParts.push(lastPart);
                    } else {
                        appendMessage("Model response part did not contain text.", 'model');
                    }
                } else {
                    appendMessage("Received an unexpected ModelContext structure from the backend.", 'model');
                    console.warn("Unexpected ModelContext structure:", lastPart);
                }
            } else {
                appendMessage("Received an empty or invalid ModelContext from the backend.", 'model');
            }

        } catch (error) {
            console.error('Failed to send message or process response:', error);
            const thinkingMsg = Array.from(chatWindow.childNodes).find(node => node.innerHTML === "<i>Thinking...</i>");
            if (thinkingMsg) {
                chatWindow.removeChild(thinkingMsg);
            }
            sendButton.disabled = false;
            appendMessage(`Network or application error: ${error.message}`, 'model');
        }    
    }

    async function previewDiff() {
        const repoName = repoInput.value.trim();
        const branchName = branchInput.value.trim();
        const filePath = filePathInput.value.trim();
        const content = fileContentInput.value;

        if (!repoName || !branchName || !filePath) {
            appendMessage('Error: repo, branch, and file path are required.', 'model');
            return;
        }

        appendMessage('<i>Generating diff...</i>', 'model');
        const diffIndicator = chatWindow.lastChild;
        previewButton.disabled = true;

        try {
            const payload = {
                repo_name: repoName,
                branch: branchName,
                files: [{ path: filePath, content: content }]
            };
            const response = await fetch('/mcp/previewChanges', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (diffIndicator && diffIndicator.parentNode === chatWindow) {
                chatWindow.removeChild(diffIndicator);
            }
            previewButton.disabled = false;

            if (!response.ok) {
                const errText = await response.text();
                appendMessage(`Error: ${errText}`, 'model');
                return;
            }

            const data = await response.json();
            if (data.status !== 'success') {
                appendMessage(`Error: ${data.error || 'Unknown error'}`, 'model');
                return;
            }

            const diffText = data.diff_text || 'No diff returned.';
            appendMessage(`<pre class="diff-block">${escapeHtml(diffText)}</pre>`, 'model');

        } catch (e) {
            if (diffIndicator && diffIndicator.parentNode === chatWindow) {
                chatWindow.removeChild(diffIndicator);
            }
            previewButton.disabled = false;
            appendMessage(`Error generating diff: ${e.message}`, 'model');
        }
    }

    sendButton.addEventListener('click', sendMessage);
    userInput.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') {
            sendMessage();
        }
    });

    if (previewButton) {
        previewButton.addEventListener('click', previewDiff);
    }

    // Optional: Initial greeting from the "model" (frontend only)
    // const initialGreetingText = "Hello! I'm ProductPod (MCP Enabled). How can I help you today?";
    // appendMessage(initialGreetingText, 'model');
    // mcpChatHistoryParts.push({
    //     type: "chat",
    //     role: "model",
    //     parts: [{ type: "text", text: initialGreetingText }]
    // });
});
