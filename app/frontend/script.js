function escapeHtml(text) {
    return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
}

function formatFunctionResponse(funcResp) {
    if (!funcResp) return '';
    const { name, response } = funcResp;

    if (name === 'listFiles' && response && Array.isArray(response.items)) {
        const rows = response.items.map(
            item => `<tr><td>${escapeHtml(item.name)}</td><td>${escapeHtml(item.type)}</td><td>${escapeHtml(item.path)}</td></tr>`
        ).join('');
        return `<table class="tool-table"><thead><tr><th>Name</th><th>Type</th><th>Path</th></tr></thead><tbody>${rows}</tbody></table>`;
    }

    if (name === 'searchFilesInRepo' && response && Array.isArray(response.results)) {
        const rows = response.results.map(
            r => `<tr><td>${escapeHtml(r.name)}</td><td>${escapeHtml(r.path)}</td><td>${escapeHtml(r.sha)}</td><td><a href="${escapeHtml(r.url)}" target="_blank">${escapeHtml(r.url)}</a></td></tr>`
        ).join('');
        return `<table class="tool-table"><thead><tr><th>Name</th><th>Path</th><th>SHA</th><th>URL</th></tr></thead><tbody>${rows}</tbody></table>`;
    }

    if (response) {
        return `<pre>${escapeHtml(JSON.stringify(response, null, 2))}</pre>`;
    }
    return '';
}

function appendMessage(content, sender, isHtml = false) {
    if (typeof document === 'undefined') return;
    const messageDiv = document.createElement('div');
    messageDiv.classList.add('message');
    messageDiv.classList.add(sender === 'user' ? 'user-message' : 'model-message');
    if (isHtml) {
        messageDiv.innerHTML = content;
    } else {
        messageDiv.textContent = content;
        messageDiv.innerHTML = messageDiv.innerHTML.replace(/\n/g, '<br>');
    }
    const chatWindow = document.getElementById('chat-window');
    chatWindow.appendChild(messageDiv);
    chatWindow.scrollTop = chatWindow.scrollHeight;
}

function processChatPart(part) {
    if (!part || part.type !== 'chat' || !Array.isArray(part.parts)) return;
    const sender = part.role === 'user' ? 'user' : 'model';
    let rendered = false;
    for (const sub of part.parts) {
        if (sub.type === 'text' && sub.text) {
            appendMessage(sub.text, sender);
            rendered = true;
        } else if (sub.function_response) {
            const html = formatFunctionResponse(sub.function_response);
            appendMessage(html || JSON.stringify(sub.function_response), sender, true);
            rendered = true;
        }
    }
    if (rendered) mcpChatHistoryParts.push(part);
}

let mcpChatHistoryParts = [];

if (typeof document !== 'undefined') {
document.addEventListener('DOMContentLoaded', () => {
    const chatWindow = document.getElementById('chat-window');
    const userInput = document.getElementById('user-input');
    const sendButton = document.getElementById('send-button');
    const previewButton = document.getElementById('preview-button');
    const repoInput = document.getElementById('repo-name');
    const branchInput = document.getElementById('branch-name');
    const filePathInput = document.getElementById('file-path');
    const fileContentInput = document.getElementById('file-content');

    // For local development, the backend runs on http://localhost:8000
    // For production, this URL will need to be the deployed backend URL.
    // Ensure this URL matches your backend deployment.
    const backendUrl = '/gemini/chat'; // Using relative path for proxy, or full URL: 'http://localhost:8000/gemini/chat';
    // const backendUrl = 'https://ai-delivery-framework-gemini-production.up.railway.app/gemini/chat';





    function escapeHtml(str) {
        return str.replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]));
    }

    async function sendMessage() {
        const messageText = userInput.value.trim();
        if (!messageText) return;

        appendMessage(messageText, 'user');

        // Create a User ChatContextPart for the current message
        const userMessagePart = {
            type: "chat", // MCP type for chat messages
            role: "user",
            parts: [{ type: "text", text: messageText }]
        };
        mcpChatHistoryParts.push(userMessagePart);

        userInput.value = ''; // Clear input field

        // Show a thinking indicator
       appendMessage("<i>Thinking...</i>", 'model');
       const thinkingMessageElement = chatWindow.lastChild;
        sendButton.disabled = true;

        try {
            // Construct the ModelContext object for the request
            const modelContextRequest = {
                // context_id: "unique-context-id-if-needed", // Optional: can be generated by backend or frontend
                parts: mcpChatHistoryParts // Send the whole history including the latest user message
            };

            console.log("Sending ModelContext to backend:", JSON.stringify(modelContextRequest, null, 2));

            const response = await fetch(backendUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(modelContextRequest),
            });

           if (thinkingMessageElement && thinkingMessageElement.parentNode === chatWindow) {
               chatWindow.removeChild(thinkingMessageElement); // Remove thinking message
           }
            sendButton.disabled = false;

            if (!response.ok) {
                let errorDetail = "Unknown error occurred";
                try {
                    const errorData = await response.json();
                    console.error('Error from backend:', response.status, errorData);
                    // Try to parse error from ModelContext if backend sends it that way
                    if (errorData.parts && errorData.parts.length > 0 &&
                        errorData.parts[0].parts && errorData.parts[0].parts.length > 0 &&
                        errorData.parts[0].parts[0].text) {
                        errorDetail = errorData.parts[0].parts[0].text;
                    } else if (errorData.detail) {
                        errorDetail = errorData.detail;
                    } else {
                        errorDetail = `Server error: ${response.statusText}`;
                    }
                } catch (e) {
                    errorDetail = `Server error: ${response.statusText} (Could not parse error response)`;
                }
                appendMessage(`Error: ${errorDetail}`, 'model');
                // Do not add this error to mcpChatHistoryParts as it's a response status, not a model message
                return;
            }

            const responseData = await response.json(); // This should be a ModelContext object
            console.log("Received ModelContext from backend:", JSON.stringify(responseData, null, 2));

            if (responseData.parts && Array.isArray(responseData.parts) && responseData.parts.length > 0) {
                responseData.parts.forEach(processChatPart);
            } else {
                appendMessage("Received an empty or invalid ModelContext from the backend.", 'model');
            }

        } catch (error) {
            console.error('Failed to send message or process response:', error);
            const thinkingMsg = Array.from(chatWindow.childNodes).find(node => node.innerHTML === "<i>Thinking...</i>");
            if (thinkingMsg) {
                chatWindow.removeChild(thinkingMsg);
            }
            sendButton.disabled = false;
            appendMessage(`Network or application error: ${error.message}`, 'model');
        }    
    }

    async function previewDiff() {
        const repoName = repoInput.value.trim();
        const branchName = branchInput.value.trim();
        const filePath = filePathInput.value.trim();
        const content = fileContentInput.value;

        if (!repoName || !branchName || !filePath) {
            appendMessage('Error: repo, branch, and file path are required.', 'model');
            return;
        }

        appendMessage('<i>Generating diff...</i>', 'model');
        const diffIndicator = chatWindow.lastChild;
        previewButton.disabled = true;

        try {
            const payload = {
                repo_name: repoName,
                branch: branchName,
                files: [{ path: filePath, content: content }]
            };
            const response = await fetch('/mcp/previewChanges', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (diffIndicator && diffIndicator.parentNode === chatWindow) {
                chatWindow.removeChild(diffIndicator);
            }
            previewButton.disabled = false;

            if (!response.ok) {
                const errText = await response.text();
                appendMessage(`Error: ${errText}`, 'model');
                return;
            }

            const data = await response.json();
            if (data.status !== 'success') {
                appendMessage(`Error: ${data.error || 'Unknown error'}`, 'model');
                return;
            }

            const diffText = data.diff_text || 'No diff returned.';
            appendMessage(`<pre class="diff-block">${escapeHtml(diffText)}</pre>`, 'model');

        } catch (e) {
            if (diffIndicator && diffIndicator.parentNode === chatWindow) {
                chatWindow.removeChild(diffIndicator);
            }
            previewButton.disabled = false;
            appendMessage(`Error generating diff: ${e.message}`, 'model');
        }
    }

    sendButton.addEventListener('click', sendMessage);
    userInput.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') {
            sendMessage();
        }
    });

    if (previewButton) {
        previewButton.addEventListener('click', previewDiff);
    }

    // Optional: Initial greeting from the "model" (frontend only)
    // const initialGreetingText = "Hello! I'm ProductPod (MCP Enabled). How can I help you today?";
    // appendMessage(initialGreetingText, 'model');
    // mcpChatHistoryParts.push({
    //     type: "chat",
    //     role: "model",
    //     parts: [{ type: "text", text: initialGreetingText }]
    // });
});
}

if (typeof module !== 'undefined') {
    module.exports = { formatFunctionResponse };
}
